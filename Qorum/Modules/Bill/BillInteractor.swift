//
//  BillInteractor.swift
//  Qorum
//
//  Created by Dima Tsurkan on 11/30/17.
//  Copyright (c) 2017 Bizico. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Mixpanel

protocol BillBusinessLogic {
    
    /// Requests Bill update
    ///
    /// - Parameter request: request for bill
    func updateBill(request: BillModels.Bill.Request)
    
    /// Asks for checkout
    ///
    /// - Parameter request: request for checkout
    func checkout(request: BillModels.CheckOut.Request)
    
    /// Asks for checkout if corresponding notification received
    ///
    /// - Parameter request: checkout request
    func checkoutFromNotif(request: BillModels.CheckOut.Request)
    
    /// Asks for tips amount update
    ///
    /// - Parameter request: tips request
    func updateGratuity(request: BillModels.Gratuity.Request)
    
    /// Tracks the checkout event
    ///
    /// - Parameter method: checkout description
    func trackClose(method: String)
}

protocol BillDataStore {
    var checkin: Checkin? { get set }
}

class BillInteractor: BillDataStore {
    
    var presenter: BillPresentationLogic?
    
    private(set) lazy var worker: BillWorker = {
        if AppConfig.fakeCheckinsEnabled {
            let fakeWorker = FakeCheckinWorker()
            fakeWorker.checkin = self.checkin
            return fakeWorker
        }
        return BillWorker()
    }()
    
    var checkin: Checkin?
    
}

// MARK: - BillBusinessLogic
extension BillInteractor: BillBusinessLogic {
    
    func updateBill(request: BillModels.Bill.Request) {
        worker.updateCheckIn(checkinId: request.checkin.checkin_id) { [weak self] result in
            switch result {
            case let .value(checkin):
                self?.checkin = checkin
                self?.presenter?.presentBill(response: result)
                self?.presenter?.presentRidesafe(for: checkin)
                if  checkin.ridesafeStatus?.isFreeRideAvailable != true,
                    !AppDelegate.shared.freeRideCheckinsHash.isEmpty,
                    let ridesafeMinTime = checkin.ridesafeStatus?.ridesafeMinTime,
                    UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastShownFreeUberRideCheckinId.rawValue) != checkin.checkin_id
                {
                    self?.presenter?.presentUnusedRidesafeAlert(ridesafeTimeMinutes: Int(Time(Double(ridesafeMinTime), .seconds)[in: .minutes]))
                    UserDefaults.standard.set(checkin.checkin_id, forKey: UserDefaultsKeys.lastShownFreeUberRideCheckinId.rawValue)
                }
            case let .error(error):
                self?.presenter?.presentBill(response: result)
                debugPrint(error)
                //if  let venue = request.checkin.venue,
                //    let genericError = error as? GenericError
                //{
                //    /* only analize server errors e.g. general, not internal ones e.g. connectivity */
                //    AnalyticsService.shared.track(event: MixpanelEvents.checkInUpdateError.rawValue,
                //                                  properties: ["Venue": venue.name,
                //                                               "Status": error.status,
                //                                               "Title": error.title])
                //}
            }
        }
    }
    
    func checkout(request: BillModels.CheckOut.Request) {
        worker.checkOut(checkinId: request.checkinId) { [weak self] result in
            let response: BillModels.CheckOut.Response
            switch result {
            case let .value(checkin):
                debugPrint("checkOut.success")
                self?.checkin = checkin
                if let venueId = checkin.venue?.venue_id {
                    QorumNotification.checkedOut.post()
                    AppDelegate.shared.checkinHash.updateValue(checkin, forKey: venueId)
                    UserDefaults.standard.set(false, for: .hasActiveCheckin)
                    UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.activeCheckinId.rawValue)
                    UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.activeCheckinVenueId.rawValue)
                }
                if let method = request.method {
                    self?.trackClose(method: method)
                }
                response = .success(checkin)
            case let .error(error):
                debugPrint(error)
                if self?.checkin?.bill?.isEmpty ?? false {
                    response = .emptyTab(error)
                } else {
                    response = .error(error)
                }
            }
            self?.presenter?.presentCheckout(response: response)
        }
    }
    
    func checkoutFromNotif(request: BillModels.CheckOut.Request) {
        debugPrint("checkOut.successHandler")
        if  let checkin = AppDelegate.shared.checkinHash.values.first(where: { $0.checkin_id == request.checkinId }),
            let venue = checkin.venue
        {
            checkin.checkout_time = Date()
            AppDelegate.shared.checkinHash.updateValue(checkin, forKey: venue.venue_id)
            UserDefaults.standard.set(false, for: .hasActiveCheckin)
            UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.activeCheckinId.rawValue)
            UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.activeCheckinVenueId.rawValue)
            
            VenueTracker.shared.trackedVenue = nil
            
            presenter?.presentCheckout(response: .success(checkin))
        }
    }
    
    func updateGratuity(request: BillModels.Gratuity.Request) {
        worker.updateGratuity(checkinId: request.checkinId, tip: request.tip) { [weak presenter] result in
            let response: BillModels.Gratuity.Response
            switch result {
            case .value:
                response = .success
            case let .error(error):
                response = .error(error)
            }
            presenter?.presentGratuity(response: response)
        }
    }
    
    func trackClose(method: String) {
        guard
            let checkin = checkin,
            let venue = checkin.venue else { return }
        let delayedCheckinId = UserDefaults.standard.integer(forKey: UserDefaultsKeys.delayedCheckinId.rawValue)
        worker.trackClose(venue: venue, checkin: checkin, method: checkin.checkin_id == delayedCheckinId ? "Auto-Close with Beacons" : method)
    }
    
}
