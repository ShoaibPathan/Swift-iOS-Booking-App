//
//  EditProfileInteractor.swift
//  Qorum
//
//  Created by Dima Tsurkan on 10/12/17.
//  Copyright (c) 2017 Bizico. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol EditProfileBusinessLogic {
    
    /// Action to perform
    ///
    /// - Parameter request: request model
    func action(_ request: EditProfile.Request)
}

protocol EditProfileDataStore {
    //var name: String { get set }
}

class EditProfileInteractor: EditProfileDataStore {
    var presenter: EditProfilePresentationLogic?
    private(set) lazy var worker = EditProfileWorker()
    //var name: String = ""
}

// MARK: - EditProfileBusinessLogic
extension EditProfileInteractor: EditProfileBusinessLogic {
    
    func action(_ request: EditProfile.Request) {
        switch request {
        case .fetchUser:
            let user = worker.user
            presenter?.present(response: .user(user))
        case let .updateUser(tableItems):
            let user = worker.user
            guard !user.isGuest else { return }
            var parameters: [String: Any] = [:]
            for tableItem in tableItems {
                switch tableItem.rawItem {
                case .firstName:
                    if tableItem.text != user.firstName ?? "" {
                        parameters["first_name"] = tableItem.text
                    }
                case .lastName:
                    if tableItem.text != user.lastName ?? "" {
                        parameters["last_name"] = tableItem.text
                    }
                case .birthDate:
                    if  tableItem.text != user.birthDate?.birthdayString ?? "",
                        let newBirthDate = Date.birthdayFormatter.date(from: tableItem.text)
                    {
                        parameters["birthdate"] = newBirthDate.backendString
                    }
                case .gender:
                    if tableItem.text != user.gender.readableLocalized {
                        parameters["gender"] = User.Gender(rawValue: tableItem.text).rawValue
                    }
                case .zipCode:
                    if tableItem.text != user.zipCode ?? "" {
                        parameters["zip"] = tableItem.text
                    }
                case .email:
                    if tableItem.text != user.email ?? "" {
                        parameters["email"] = tableItem.text
                    }
                case .phone:
                    if let phone = user.phoneFormatted {
                        if tableItem.text != phone {
                            parameters["phone"] = tableItem.text
                        }
                    } else if !tableItem.text.isEmpty {
                        parameters["phone"] = tableItem.text
                    }
                }
            }
            guard !parameters.isEmpty else { return }
            presenter?.present(response: .updateState(.started))
            worker.updateUser(id: user.userId, parameters: parameters) { [weak self] result in
                switch result {
                case .value:
                    ProfileWorker().fetchUser(id: user.userId) { [weak self] result in
                        self?.presenter?.present(response: .updateState(.finished))
                        switch result {
                        case let .value(fetchedUser):
                            fetchedUser.isAvatarPlaceholder = user.isAvatarPlaceholder
                            fetchedUser.save()
                            self?.action(.fetchUser)
                            if !(user.mobileNumber ?? "").isEmpty, parameters["phone"] != nil, !user.isPhoneVerified {
                                self?.presenter?.present(response: .needsVerifyPhone)
                            } else {
                                self?.presenter?.present(response: .updatedUser)
                            }
                            
                            // TODO: - need to replicate the following functionality @sshemiakov
                            
                            //if QorumAPIClient.sharedInstance.userCanCheckIn(isSilent: true) {
                            //    let notification = Notification(name: Notification.Name(rawValue: self.user.userCanCheckInNotificationName),
                            //                                    object: self.user)
                            //    NotificationCenter.default.post(notification)
                            //}
                            
                        case let .error(error):
                            print("Failed to fetch User after updating: \n", error)
                            self?.presenter?.present(response: .failedToUpdateUser("There was a problem updating your profile. Please try again."))
                        }
                    }
                case let .error(error):
                    self?.presenter?.present(response: .updateState(.finished))
                    print("worker.updateUser - error:", error.localizedDescription, error)
                    let message: String
                    if let genericError = error as? GenericError,
                        let detail = genericError.detail.string,
                        detail.isNotEmpty
                    {
                        message = detail
                    } else {
                        message = "There was a problem updating your profile. Please try again."
                    }
                    self?.presenter?.present(response: .failedToUpdateUser(message))
                }
            }
        case .verifyPhone:
            // worker.verify
            // TODO: phone verification
            break
        }
    }
    
}
