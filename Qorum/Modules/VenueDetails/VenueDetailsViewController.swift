//
//  VenueDetailsViewController.swift
//  Qorum
//
//  Created by Dima Tsurkan on 11/16/17.
//  Copyright (c) 2017 Bizico. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import UserNotifications
import SMPageControl
import AVFoundation
import VisualEffectView
import Mixpanel

protocol VenueDetailsDisplayLogic: class {
    
    /// Updates UI after user login.
    /// Also starts to load last checkins.
    func displayLoggedInUser()
    
    /// Updates UI after checkins loading.
    /// The checkins loading happens after user login.
    func displayLoadedCheckins()
    
    /// Opens the `Bill` scene as a result of tab opening request.
    ///
    /// - Parameter viewModel: The tab opening request response, which is expected to be successful.
    func displayCheckin(viewModel: VenueDetails.CheckIn.ViewModel)
    
    /// Notifies user about tab opening request failure details.
    ///
    /// - Parameter viewModel: The tab opening request failure details.
    func displayCheckinError(viewModel: VenueDetails.CheckIn.ViewModel)
    
    /// Notifies user about preconditions failure details on attempt to open a tab.
    ///
    /// - Parameter viewModel: The preconditions failure details.
    func displayPreconditionsError(viewModel: VenueDetails.Preconditions)
    
    /// Starts opening a tab.
    func displayPreconditionsSuccess()
    
    /// Asks the `QorumProgressHUD` to present plain loading HUD.
    func showLoader()
    
    /// Asks the `QorumProgressHUD` to present loading HUD with given message.
    ///
    /// - Parameter message: The message shown on the HUD. `nil` means no messsage.
    func showLoader(_ message: String?)
    
    /// Asks the `QorumProgressHUD` to dismiss.
    func hideLoader()
    
    /// Presents an alert saying you are of illegal age to use the app.
    /// Used in case when logged in user is under age of 21.
    func displayAgeAlert()
    
    /// Adds an overlay for given overlay case and displays it.
    ///
    /// - Parameter overlay: Defines an overlay to add.
    func displayOverlay(_ overlay: VenueDetails.Overlay)
    
}

class VenueDetailsViewController: BaseViewController, SBInstantiable, TipFeaturesHoursDelegate {
    
    static let storyboardName = StoryboardName.venueDetails
    var interactor: (VenueDetailsBusinessLogic & VenueDetailsDataStore)?
    var router: (NSObjectProtocol & VenueDetailsRoutingLogic & VenueDetailsDataPassing)?
    
    /// The venue this scene represents
    var venue: Venue? {
        didSet { genderMeasureView.reloadData() }
    }
    
    var pageControl = SMPageControl()
    
    /// Broken boolean. Should be removed or moved to interactor.
    var pageControlPressed = false
    
    /// Used to hide the status bar when opening the gallery in landscape.
    var shouldHideStatusBar = false {
        didSet {
            setNeedsStatusBarAppearanceUpdate()
        }
    }
    
    var venueMarker: VenueMarker?
    var checkin: Checkin?
    
    /// The flag for an event that must be called only once.
    var shouldScrollToMap = true
    
    /// The flag for an event that must be called only once.
    var shouldConfigGallery = true
    
    /// The flag for an event that must be called only once.
    var shouldConfigMap = true
    
    /// Whether the map view is expanded.
    var isMapOpened = false
    
    /// Defines whether it's checking in from the venues list via the 'open tab' swipe
    var isCheckingInFromList = false
    
    /// Need to continue precondition steps up to checkin after compleating them
    var isCheckingIn = false
    
    /// Need to check once before open a tab
    var bluetoothChecked = false
    
    /// Required to detect successfull authorization and to not interrupt preconditions flow
    var isLoggingIn = false
    
    /// The overlay view controller.
    /// Currently used for facebook login overlay.
    weak var overlay: UIViewController?
    
    weak var featuresController: TipFeaturesHoursController!
    
    /// Displays users who have checked in this venue.
    weak var friendsContainer: FriendsContainerController?
    
    // MARK: - Outlets
    
    @IBOutlet weak var bottomViewsContainer: UIView!
    @IBOutlet weak var uberButton: UIView!
    @IBOutlet weak var openTabButton: UIView!
    @IBOutlet weak var viewTabButton: UIView!
    @IBOutlet weak var closedContainer: UIView!
    @IBOutlet weak var uberEstimateLabel: UILabel!
    
    @IBOutlet weak var backButton: UIButton!
    @IBOutlet weak var shareButton: UIButton!
    @IBOutlet weak var container: UIScrollView!
    @IBOutlet weak var gallery: GalleryView!
    @IBOutlet weak var galleryHeight: NSLayoutConstraint!
    @IBOutlet weak var galleryTop: NSLayoutConstraint!
    @IBOutlet weak var containerBottom: NSLayoutConstraint!
    @IBOutlet weak var galleryBackground: UIView!
    
    weak var galleryGrid: GridView?
    
    @IBOutlet weak var mapTitleBlur: VisualEffectView!
    @IBOutlet weak var mapView: GMSMapView!
    @IBOutlet weak var closeMapView: GradientInspectableView!
    @IBOutlet weak var mapContainer: UIView!
    @IBOutlet weak var mapExpandable: UIView!
    @IBOutlet weak var mapBottomGradient: GradientView!
    
    @IBOutlet weak var mapTitle: UILabel!
    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var navNameLabel: UILabel!
    @IBOutlet weak var discountLabel: UILabel!
    @IBOutlet weak var distanceLabel: UILabel!
    @IBOutlet weak var venueTypeLabel: UILabel!
    @IBOutlet weak var venueTypeIcon: UIImageView!
    @IBOutlet weak var descriptionView: VenueDetailsDescriptionView!
    @IBOutlet weak var phoneButton: PhoneButton!
    @IBOutlet weak var phoneButtonHeight: NSLayoutConstraint!
    @IBOutlet weak var featuresHeight: NSLayoutConstraint!
    @IBOutlet weak var friendsHeight: NSLayoutConstraint!
    @IBOutlet weak var friendsHeaderStackView: UIStackView!
    @IBOutlet weak var facebookButton: UIButton!
    @IBOutlet weak var navigationView: UIView!
    
    @IBOutlet weak var specialNoticeLabel: UILabel!
    @IBOutlet weak var specialNoticeView: UIView!
    @IBOutlet weak var specialNoticeTop: NSLayoutConstraint!
    
    @IBOutlet weak var genderMeasureView: GenderMeasureView! {
        didSet {
            oldValue?.dataSource = nil
            genderMeasureView.dataSource = self
        }
    }
    
    /// Returns safe area top inset
    lazy var iphoneXFixTop: CGFloat = {
        return UIApplication.shared.safeAreaInsets.top
    }()
    
    /// Returns safe area bottom inset
    lazy var iphoneXFixBot: CGFloat = {
        return UIApplication.shared.safeAreaInsets.bottom
    }()
    
    // MARK: - Object lifecycle
    
    deinit {
        print("deinit details")
    }
    
    required override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    private func setup() {
        modalPresentationStyle = .custom
        modalTransitionStyle = .crossDissolve
        modalPresentationCapturesStatusBarAppearance = true
        let viewController = self
        let interactor = VenueDetailsInteractor()
        let presenter = VenueDetailsPresenter()
        let router = VenueDetailsRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        interactor.authPresenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    override var prefersStatusBarHidden: Bool {
        return shouldHideStatusBar
    }
    
    override var backgroundStyle: BaseViewController.BackgroundAppearance {
        return .empty
    }
    
    // MARK: - View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        venue = router?.dataStore?.venue
        configureView()
        configurePageControl()
        configureFeatures()
        interactor?.mayShowOverlay()
        if let customPopGestureRecognizer = (navigationController as? BaseNavigationController)?.customPopGestureRecognizer {
            gallery.panGestureRecognizer.require(toFail: customPopGestureRecognizer)
            featuresController?.view.subviews.find(UIScrollView.self)?.panGestureRecognizer.require(toFail: customPopGestureRecognizer)
        }
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        updateButtons()
        updateCustomersSectionState()
        configureGallery()
        configureMap()
        fetchUberEstimates()
        if shouldScrollToMap == true {
            shouldScrollToMap = false
            checkMapFits()
        }
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        if isCheckingIn == true && isLoggingIn == false {
            if !UserDefaults.standard.bool(for: .pendingEmailVerification) || isCheckingInFromList {
                isCheckingInFromList = false
                perform(#selector(openTabButtonPressed), with: nil, afterDelay: 0.1)
            } else {
                cancelCheckinAction()
                router?.routeToVenues()
            }
        }
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        if let videoView = gallery.playerView {
            videoView.stopPlaying()
            videoView.finishSession()
        }
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        descriptionView.updateContentSize()
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return isMapOpened ? .default : .lightContent
    }
    
    // MARK: - Internal
    
    private func configureView() {
        mapBottomGradient.isHidden = false
        fillWithVenue()
        fillDescription()
        configPhoneNumber()
    }
    
    func configPhoneNumber() {
        if let phone_number = venue?.phone_number {
            phoneButton.adjustWithPhone(phone_number)
            phoneButtonHeight.constant = 50
        } else {
            phoneButtonHeight.constant = 0
        }
    }
    
    private func configurePageControl() {
        pageControl.tintColor = .white
        pageControl.hidesForSinglePage = true
        pageControl.numberOfPages = (venue?.gallery_urls.count ?? 0) + ((venue?.video_url) == nil ? 0 : 1)
        pageControl.sizeToFit()
        pageControl.frame = CGRect(x: (.deviceWidth - pageControl.width)/2.0, y: .deviceWidth - pageControl.height - 10, width: pageControl.width, height: pageControl.height)
        pageControl.currentPage = 0
        pageControlPressed = false
        container.addSubview(pageControl)
    }
    
    private func configureGallery() {
        guard shouldConfigGallery else { return }
        
        shouldConfigGallery = false
        galleryTop.constant = 0
        galleryHeight.constant = .deviceWidth
        container.layoutSubviews()
        gallery.bounces = true
        
        refillGallery()
    }
    
    func configureSpecialNoticeVisibility() {
        let isAvailable = (venue?.specialNotice).isNotNilNorEmpty
        let isVideoPlaying = gallery.playerView?.player.isPlaying == true
        let isGalleryPortrait = gallery.state == .short
        specialNoticeView.isHidden = !isAvailable || isVideoPlaying || !isGalleryPortrait
    }
    
    private func refillGallery() {
        gallery.subviews.forEach({ $0.removeFromSuperview() })
        gallery.contentSize = CGSize(width: .deviceWidth * CGFloat(venue?.gallery_urls.count ?? 0), height: .deviceWidth)
        gallery.setContentOffset(CGPoint.zero, animated: false)
        gallery.layoutIfNeeded()
        
        if let venue = venue {
            gallery.fillFromVenue(venue: venue, delegate: self)
        }
    }
    
    private func configureMap() {
        guard shouldConfigMap else { return }
        
        shouldConfigMap = false
        mapView.delegate = self
        mapView.settings.scrollGestures = false
        mapView.settings.zoomGestures = true
        mapView.isUserInteractionEnabled = false
        if LocationService.shared.isLocationDisabled {
            LocationService.shared.requestAuthorization(isAlwaysUse: false) {[weak self] (status) in
                self?.mapView.isMyLocationEnabled = status == .authorizedWhenInUse || status == .authorizedAlways
            }
        } else {
            mapView.isMyLocationEnabled = true
        }
        
        let mapContainerPosY = container.convert(mapContainer.frame, to: view).origin.y
        
        closeMapView.snp.makeConstraints({ (make) in
            make.top.equalTo(mapExpandable.snp.top).offset(-mapContainerPosY)
        })
        
        mapBottomGradient.snp.makeConstraints({ (make) in
            make.bottom.equalTo(mapExpandable.snp.bottom).offset(44)
        })
        
        mapTitle.adjustsFontSizeToFitWidth = true
        if let slogan = venue?.slogan?.uppercased() {
            mapTitle.text = "\"\(slogan)\""
        }
        
        mapExpandable.layer.masksToBounds = true
        
        if venueMarker != nil {
            venueMarker?.map = nil
            venueMarker = nil
        }
        
        if let venue = venue {
            venueMarker = VenueMarker(with: venue, preferAddresses: true)
            venueMarker!.position = venue.coordinate
            venueMarker!.map = mapView
            mapView.camera = GMSCameraPosition.camera(withTarget: venueMarker!.position, zoom: 13.5)
        }
        
        do {
            if let styleURL = Bundle.main.url(forResource: "UberMapStyle", withExtension: "json") {
                self.mapView.mapStyle = try GMSMapStyle(contentsOfFileURL: styleURL)
            }
        } catch {
            print("One or more of the map styles failed to load. \(error)")
        }
    }
    
    private func configureFeatures() {
        featuresController = childViewControllers.find(TipFeaturesHoursController.self)
        featuresController.venue = venue
        featuresController.featuresDelegate = self
        featuresController.adjustWithVenue()
    }
    
    /// Updates "See who's here" section.
    private func updateCustomersSectionState() {
        let user = User.stored
        guard !user.isGuest, user.isFacebookVisible else {
            let fakeCustomers = Avatar.generateFake()
            friendsContainer = childViewControllers.find(FriendsContainerController.self)
            friendsContainer?.friends = fakeCustomers
            updateCustomerSectionFrame()
            print("display fake friends")
            return
        }
        
        interactor?.loadFriends { result in
            switch result {
            case let .value(friends):
                var checkedCustomers: [Avatar] = []
                let users = Array(self.venue!.checkedInUsersVisible)
                checkedCustomers = users.map({ (avatar) -> Avatar in
                    avatar.isFacebookFriend = friends.contains { $0.id == avatar.facebookId }
                    return avatar
                }).sorted(by: { (av1, av2) -> Bool in
                    return av1.isFacebookFriend == true
                })
                
                DispatchQueue.main.async {
                    self.friendsContainer = self.childViewControllers.find(FriendsContainerController.self)
                    self.friendsContainer?.friends = checkedCustomers
                    self.updateCustomerSectionFrame()
                    print("display friends \(friends)")
                }
            case let .error(error):
                print(" error:", error)
            }
        }
    }
    
    private func updateCustomerSectionFrame() {
        let user = User.stored
        if user.isGuest == false && user.isFacebookVisible == true {
            facebookButton.isHidden = true
            let count = self.friendsContainer?.friends.count ?? 0
            
            friendsHeaderStackView.isHidden = count < 1
            genderMeasureView.isHidden = count < 1
            
            let contentHeight = ceil(CGFloat(count)/2) * .deviceWidth / 2
            friendsHeight.constant = CGFloat(contentHeight)
        } else if user.facebookVisible == "limbo" {
            friendsHeaderStackView.isHidden = true
            facebookButton.isHidden = true
            friendsHeight.constant = 0
        } else {
            friendsHeaderStackView.isHidden = false
            facebookButton.isHidden = false
            let count = self.friendsContainer?.friends.count ?? 0
            genderMeasureView.isHidden = true
            let contentHeight = ceil(CGFloat(count)/2) * .deviceWidth / 2
            friendsHeight.constant = CGFloat(contentHeight)
            if user.isGuest == true {
                let text = "CONNECT WITH FACEBOOK"
                let attrString = NSMutableAttributedString(string: text)
                var range = (text as NSString).range(of: "FACEBOOK")
                range.length = ("FACEBOOK" as NSString).length
                attrString.addAttribute(NSAttributedStringKey.font, value: UIFont.montserrat.bold(14), range: range)
                facebookButton.setAttributedTitle(attrString, for: .normal)
            } else {
                facebookButton.setTitle("TURN ON VISIBILITY" , for: .normal)
            }
        }
        self.view.layoutIfNeeded()
    }
    
    /// Updates the bottom button appearance according to the venue/tab status.
    private func updateButtons() {
        guard let venue = venue else { return }
        
        viewTabButton.isHidden = true
        closedContainer.isHidden = true
        openTabButton.isHidden = true
        uberButton.isHidden = true
        
        let tooFarToCheckIn = LocationService.shared.tooFarForCheckin(venue.coordinate)
        var checkedIn = false
        if let hashedCheckin = AppDelegate.shared.checkinHash[venue.venue_id], hashedCheckin.checkout_time == nil {
            self.checkin = hashedCheckin
            checkedIn = true
            viewTabButton.isHidden = false
        }
        
        openTabButton.isHidden = tooFarToCheckIn || checkedIn
        uberButton.isHidden = false
        switch venue.status() {
        case .opensLater, .closed:
            closedContainer.isHidden = false
        default:
            closedContainer.isHidden = true
        }
    }
    
    /// Checks email verification status,
    /// then asks interactor to continue preconditions check.
    private func checkPreconditions() {
        isCheckingIn = true
        let user = User.stored
        guard !user.isGuest else {
            hideLoader()
            UIAlertController.presentAsAlert(message: "You must log in to open a tab", actions:
                [("Cancel", .cancel, { [weak self] in self?.cancelCheckinAction() }),
                 ("Log in", .default, { [weak self] in self?.loginAction() })])
            return
        }
        
        guard !user.isAvatarPlaceholder || UserDefaults.standard.bool(for: .didShowNoAvatarAlert) else {
            hideLoader()
            let message = "Add your profile picture, so the bartenders can update to your tab."
            UIAlertController.presentAsAlert(message: message, actions:
                [("Cancel", .cancel, { [weak self] in self?.cancelCheckinAction() }),
                 ("Add profile Picture", .default, { [weak self] in self?.AddPhotoAction() })])
            return
        }
        showLoader("Checking preconditions")
        guard user.isEmailVerified else {
            ProfileWorker().fetchAndSave(user: user) { [weak self] fetchedUser in
                if let fetchedUser = fetchedUser, fetchedUser.isEmailVerified {
                    self?.interactor?.checkPreconditions()
                } else if UserDefaults.standard.bool(for: .pendingEmailVerification) {
                    let pendingMessage = "Please check your email inbox for the verification email from Qorum. In the email, tap on the verification link to confirm your email address is correct. If you do not wish to verify your email, you cannot open a tab via the Qorum app"
                    let changeEmailAction: UIAlertController.CustomAction
                    changeEmailAction = ("Change Email", .cancel, { [weak self] in
                        self?.hideLoader()
                        self?.router?.routeToEmailVerification()
                    })
                    let gotItAction: UIAlertController.CustomAction
                    gotItAction = ("Got It", .default, { [weak self] in
                        User.stored.checkEmailStatus { [weak self] isVerified in
                            if isVerified {
                                self?.interactor?.checkPreconditions()
                            } else {
                                self?.hideLoader()
                                self?.cancelCheckinAction()
                                self?.router?.routeToVenues()
                            }
                        }
                    })
                    UIAlertController.presentAsAlert(title: "Pending email verification",
                                                     message: pendingMessage,
                                                     actions: [changeEmailAction, gotItAction])
                } else {
                    self?.hideLoader()
                    let verifyEmailMessage = "Please verify your email address to receive your Qorum receipts."
                    let cancelAction: UIAlertController.CustomAction
                    cancelAction = ("Cancel", .cancel, { [weak self] in
                        self?.cancelCheckinAction()
                        self?.router?.routeToVenues()
                    })
                    let verifyEmailAction: UIAlertController.CustomAction
                    verifyEmailAction = ("Verify Email", .default, { [weak self] in
                        self?.router?.routeToEmailVerification()
                    })
                    UIAlertController.presentAsAlert(message: verifyEmailMessage,
                                                     actions: [cancelAction, verifyEmailAction])
                }
            }
            return
        }
        interactor?.checkPreconditions()
    }
    
    @objc private func loginAction() {
        isLoggingIn = true
        interactor?.login()
    }
    
    /// Breaks the tab opening in flow.
    /// Used when user refused to meet preconditions or just cancelled the tab opening.
    @objc private func cancelCheckinAction() {
        isLoggingIn = false
        isCheckingIn = false
        VenueTracker.shared.isCheckingIn = false
    }
    
    /// Routes to the adding new payment card scene.
    /// Used when user doesn't have a card to pay for the tab items with.
    @objc private func addCreditCard() {
        router?.routeToAddPayments()
    }
    
    /// Routes to the Payments scene in order to change card that fits preconditions i.e preauthorization funds.
    @objc private func changePaymentAction() {
        self.isCheckingIn = true
        router?.routeToPayments()
    }
    
    /// Routes to the adding photo scene.
    @objc private func AddPhotoAction() {
        router?.routeToPhoto()
    }
    
    private func fillWithVenue() {
        if let discount = venue?.discount {
            discountLabel.isHidden = false
            discountLabel.text = discount >= 0 ? String(format: "%.0f%@", arguments: [discount , NSLocalizedString("% OFF", comment: "")]) : ""
        } else { discountLabel.isHidden = true }
        
        if iphoneXFixTop != 0 {
            specialNoticeTop.constant = 85
        }
        specialNoticeLabel.text = venue?.specialNotice
        if let venueType = venue?.venue_type {
            let color: UIColor = .venueColor(venueType)
            specialNoticeView.backgroundColor = color.withAlphaComponent(0.3)
        }
        configureSpecialNoticeVisibility()
        
        nameLabel.text = venue?.name ?? ""
        navNameLabel.text = venue?.name ?? ""
        venueTypeIcon.tintColor = .venueColor(venue?.venue_type ?? "")
        venueTypeLabel.text = venue?.venueTypeText
        distanceLabel.text = venue?.distanceText
    }
    
    /// Forms an array of `venue_description` components and passes these to the `descriptionView`.
    private func fillDescription() {
        let array = venue?.venue_description?.components(separatedBy: "***") ?? []
        descriptionView.fill(array)
    }
    
    /// Scrolls the Details Screen so the map becomes visible, if needed.
    private func checkMapFits() {
        let reqOffset = (mapContainer.y + mapContainer.height + 10) - container.height
        if reqOffset > 0 {
            container.setContentOffset(CGPoint(x: 0, y: reqOffset), animated: false)
        }
    }
    
    private func fetchUberEstimates() {
        if LocationService.shared.tooFarToRide(venue?.coordinate) {
            uberEstimateLabel.text = "TOO FAR"
        } else if self.uberEstimateLabel.text == "", LocationService.shared.tooFarForCheckin(venue?.coordinate) {
            interactor?.getPriceEstimate(venue!, handler: { (success, estimates) in
                if success == true, estimates.count > 0 {
                    var estimate = estimates[0]
                    for e in estimates {
                        if e.name == "uberX" {
                            estimate = e
                        }
                    }
                    
                    DispatchQueue.main.async {
                        var str = ""
                        if let price = estimate.priceRange {
                            str = price
                        }
                        if let duration = estimate.duration {
                            str = "\(duration / 60) MIN, \(str)"
                        }
                        
                        self.uberEstimateLabel.text = str
                    }
                }
            })
        }
    }
    
    // MARK: - Actions
    
    /// Routes back.
    @IBAction func backButtonPressed(_ sender: Any) {
        router?.routeToVenues()
    }
    
    /// Asks interactor to prepare data for sharing the venue.
    @IBAction func shareButtonPressed(_ sender: Any) {
        interactor?.share(from: self)
    }
    
    /// Checks preconditions and opens a tab.
    @IBAction func openTabButtonPressed(_ sender: Any?) {
        guard BluetoothHelper.shared.state == .poweredOn || bluetoothChecked == true else {
            isCheckingIn = true
            bluetoothChecked = true
            router?.navigateToBluetoothRequest(source: self)
            return
        }
        checkPreconditions()
    }
    
    /// Routes to the `Bill` scene.
    /// Accessible when the venue has active checkin i.e the tab is open now.
    @IBAction func viewTabPressed() {
        interactor?.checkin = self.checkin
        router?.routeToVenueBill()
    }
    
    /// Logs user in or routes to facebook visibility settings, if needed.
    @IBAction func facebookButtonPressed() {
        if User.stored.isGuest == true {
            loginAction()
        } else if User.stored.isFacebookVisible == false {
            router?.routeToFacebookSettings()
        }
    }
    
    /// Routes to the Uber ordering scene if accessible.
    @IBAction func uberButtonPressed() {
        guard uberEstimateLabel.text != "TOO FAR", uberEstimateLabel.text != "" else {
            return
        }
        if User.stored.isGuest {
            loginAction()
            return
        }
        router?.routeToUber()
    }
    
    func showMenuPressed() {
        router?.routeToMenu()
    }
    
    /// Expands the map view.
    @IBAction func tappedMap() {
        guard mapExpandable.superview != view else { return }
        
        venueMarker?.tracksViewChanges = true
        
        let mapContainerPosY = container.convert(mapContainer.frame, to: view).origin.y
        closeMapView.snp.updateConstraints { (update) in
            update.top.equalTo(-mapContainerPosY)
        }
        self.view.layoutIfNeeded()
        
        container.isScrollEnabled = false
        mapExpandable.frame = container.convert(mapContainer.frame, to: view)
        
        mapBottomGradient.snp.updateConstraints { (update) in
            update.bottom.equalTo(-iphoneXFixBot)
        }
        
        view.addSubview(mapExpandable)
        mapExpandable.snp.removeConstraints()
        mapExpandable.snp.makeConstraints { (make) in
            make.top.equalTo(view).offset(mapExpandable.y)
            make.left.equalTo(view).offset(15)
            make.right.equalTo(view).offset(-15)
            make.height.equalTo(view.height)
        }
        
        mapTitleBlur.isHidden = true
        mapTitle.isHidden = true
        
        closeMapView.snp.updateConstraints { (update) in
            update.top.equalTo(0)
        }
        
        mapExpandable.snp.updateConstraints { (update) in
            update.left.right.equalTo(0)
            update.top.equalTo(0)
            update.height.equalTo(view.height)
        }
        
        if let videoView = gallery.playerView {
            videoView.stopPlaying()
        }
        
        view.bringSubview(toFront: mapExpandable)
        
        isMapOpened = true
        
        UIView.animate(withDuration: 0.4, delay: 0, options: .curveEaseOut, animations: { [weak self] in
            self?.mapExpandable.layer.cornerRadius = 0
            self?.mapView.padding = UIEdgeInsets(top: 0, left: 0, bottom: 10, right: 0)
            self?.setNeedsStatusBarAppearanceUpdate()
            self?.view.layoutIfNeeded()
        }) { [weak self] _ in
            self?.mapView.settings.scrollGestures = true
            self?.mapView.isUserInteractionEnabled = true
            self?.mapContainer.gestureRecognizers?.first?.isEnabled = false
        }
        
        zoomMapIn(zoomIn: true)
        setNeedsStatusBarAppearanceUpdate()
    }
    
    /// Shrinks the map view.
    @IBAction func closeMapViewButtonPressed() {
        venueMarker?.shrink()
        let mapContainerPosY = container.convert(mapContainer.frame, to: view).origin.y
        
        closeMapView.snp.updateConstraints { (update) in
            update.top.equalTo(-mapContainerPosY)
        }
        
        mapBottomGradient.snp.updateConstraints { (update) in
            update.bottom.equalTo(44)
        }
        
        mapExpandable.snp.updateConstraints { (update) in
            update.top.equalTo(view).offset(mapContainerPosY)
            update.left.equalTo(view).offset(15)
            update.right.equalTo(view).offset(-15)
            update.height.equalTo(mapContainer.height)
        }
        
        isMapOpened = false
        
        UIView.animate(withDuration: 0.4, delay: 0, options: .curveEaseOut, animations: { [weak self] in
            self?.mapExpandable.layer.cornerRadius = 5
            self?.setNeedsStatusBarAppearanceUpdate()
            self?.mapView.padding = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
            self?.view.layoutIfNeeded()
        }) { [weak self] _ in
            self?.mapExpandable.snp.removeConstraints()
            self?.mapContainer.addSubview(self!.mapExpandable)
            self?.mapExpandable.snp.makeConstraints { make in
                make.top.left.right.bottom.equalTo(self!.mapContainer)
            }
            self?.mapTitleBlur.isHidden = false
            self?.mapTitle.isHidden = false
            self?.mapView.settings.scrollGestures = false
            self?.mapView.isUserInteractionEnabled = false
            self?.mapContainer.gestureRecognizers?.first?.isEnabled = true
            self?.container.isScrollEnabled = true
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) { [weak self] in
            self?.venueMarker?.tracksViewChanges = false
            self?.zoomMapIn(zoomIn: false)
        }
        setNeedsStatusBarAppearanceUpdate()
    }
    
    //MARK: - Map
    
    func zoomMapIn(zoomIn: Bool) {
        if let coordinate = venue?.coordinate {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                CATransaction.begin()
                CATransaction.setValue(0.5, forKey: kCATransactionAnimationDuration)
                CATransaction.setValue(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn), forKey: kCATransactionAnimationTimingFunction)
                let cameraUpdate = GMSCameraUpdate.setTarget(coordinate, zoom: zoomIn ? 15.5 : 13.5)
                self.mapView.animate(with: cameraUpdate)
                CATransaction.commit()
            }
        }
    }
    
    /// Copies the venue address.
    /// Called on long pressing the venue marker in the map view.
    @IBAction func pinLongPressed(_ longPressGesture: UILongPressGestureRecognizer) {
        if let address = venueMarker?.markerContainer.nameLabel.text {
            UIPasteboard.general.string = address
            let mb = MBProgressHUD.showAdded(to: mapExpandable, animated: true)
            mb?.mode = .text
            mb?.labelText = "Copied!"
            mb?.labelColor = .black
            mb?.removeFromSuperViewOnHide = true
            mb?.color = UIColor.white.withAlphaComponent(0.8)
            mb?.hide(true, afterDelay: 2)
        }
    }
    
    //MARK: - Gallery
    
    /// Opens or closes (i.e expands/shrinks) main gallery
    @objc func openGalleryPressed() {
        if mapExpandable.superview == self.view {
            return
        }
        if view.subviews.index(of: container) == 0 { // expands the gallery
            galleryBackground.isHidden = false
            gallery.currentInd = Int(gallery.contentOffset.x / .deviceWidth)
            view.bringSubview(toFront: container)
            galleryHeight.constant = .deviceHeight
            container.layoutSubviews()
            container.setContentOffset(CGPoint.zero, animated: false)
            container.isScrollEnabled = false
            containerBottom.constant = 0
            bottomViewsContainer.isHidden = true
            navigationView.isHidden = true
            pageControl.isHidden = true
            gallery.display(state: .expanded)
            BaseNavigationController.baseRoot?.isFadeInteractorEnabled = false
        } else { // shrinks the gallery
            BaseNavigationController.baseRoot?.isFadeInteractorEnabled = true
            galleryBackground.isHidden = true
            view.sendSubview(toBack: container)
            galleryHeight.constant = .deviceWidth
            containerBottom.constant = bottomViewsContainer.height
            bottomViewsContainer.isHidden = false
            navigationView.isHidden = false
            container.layoutSubviews()
            pageControl.isHidden = false
            self.gallery.display(state: .short)
            pageControl.y = galleryHeight.constant - pageControl.height - 10
            container.isScrollEnabled = true
        }
        configureSpecialNoticeVisibility()
    }
    
    //MARK: - Gallery Grid
    
    /// Opens grid mode gallery (usually on top of main gallery).
    ///
    /// - Parameter currentIndex: Defines gallery item to scroll to on opening.
    func openGalleryGridPressed(currentIndex: Int = 0) {
        guard venue != .none else { return }
        gallery.playerView?.stopPlaying()
        let grid = GridView(frame: view.bounds)
        grid.fillFromVenue(venue: venue!, delegate: self)
        let indexPath = IndexPath(row: currentIndex, section: 0)
        grid.collectionView.scrollToItem(at: indexPath, at: .top, animated: true)
        galleryGrid = grid
        view.addSubview(grid)
        UIDevice.current.endGeneratingDeviceOrientationNotifications()
        Notification.Name.UIDeviceOrientationDidChange.remove(observer: gallery)
        gallery.closeTapped()
        BaseNavigationController.baseRoot?.isFadeInteractorEnabled = false
    }
    
    /// Closes grid mode gallery.
    ///
    /// - Parameter selectedIndex: Defines gallery item to move to in the gallery. If `nil` passed, it will close main gallery as well.
    func closeGalleryGridPressed(selectedIndex: Int? = .none) {
        if let indexTo = selectedIndex {
            let rect = CGRect(x: .deviceWidth * CGFloat(indexTo), y: 0, width: .deviceWidth, height: .deviceWidth)
            gallery.scrollRectToVisible(rect, animated: false)
            openGalleryPressed()
        } else {
            gallery.closeTapped()
        }
        galleryGrid?.removeFromSuperview()
        UIDevice.current.beginGeneratingDeviceOrientationNotifications()
        let orientationNotification = Notification.Name.UIDeviceOrientationDidChange
        orientationNotification.remove(observer: gallery)
        orientationNotification.add(observer: gallery, selector: #selector(gallery.didChangeOrientation))
        if selectedIndex == .none {
            openGalleryPressed()
        }
    }
    
}

extension VenueDetailsViewController: VenueDetailsDisplayLogic {
    
    // MARK: - VenueDetailsDisplayLogic
    
    /// Routes to Bluetooth request scene if needed.
    /// Also asks interactor to load last checkins.
    func displayLoggedInUser() {
        if BluetoothHelper.shared.state == .poweredOff && bluetoothChecked == false {
            router?.navigateToBluetoothRequest(source: self)
        }
        interactor?.fetchLastCheckins()
    }
    
    /// Handles loaded checking afer user login.
    func displayLoadedCheckins() {
        UIView.animate(withDuration: 1, animations: { [weak self] in
            self?.overlay?.view.alpha = 0
        }) { [weak self] _ in
            self?.overlay?.removeFromParentController()
        }
        isLoggingIn = false
        updateCustomersSectionState()
        if isCheckingIn == true {
            openTabButtonPressed(nil)
        }
    }
    
    /// Displays an alert notifying user about tab opening preconditions failure according to given details.
    ///
    /// - Parameter viewModel: Indicates failure reasons.
    func displayPreconditionsError(viewModel: VenueDetails.Preconditions) {
        hideLoader()
        openTabButton.isUserInteractionEnabled = true
        if let _ = viewModel.preconditionCases["payment_card"] {
            let message = "Please add a credit card to open your bar tab and enjoy your Qorum discount."
            UIAlertController.presentAsAlert(title: "Check in?", message: message, actions:
                [("Cancel", .cancel, { [weak self] in self?.cancelCheckinAction() }),
                 ("Add Card", .default, { [weak self] in self?.addCreditCard()})])
        } else {
            let message = viewModel.preconditionCases.values.joined(separator: ",\n")
            UIAlertController.presentAsAlert(title: "Cannot Open Tab", message: message, actions:
                [("Cancel", .cancel, { [weak self] in self?.cancelCheckinAction() })])
        }
    }
    
    /// Asks interactor to open a tab.
    func displayPreconditionsSuccess() {
        isCheckingIn = false
        if let venueId = router?.dataStore?.venue?.venue_id {
            showLoader("Opening Tab")
            
            let request = VenueDetails.CheckIn.Request(venueId: String(describing: venueId))
            interactor?.openNewCheckIn(request: request)
        }
    }
    
    /// Routes to the `Bill` scene and passes the checkin data from given viewModel.
    ///
    /// - Parameter viewModel: Contains checkin data.
    func displayCheckin(viewModel: VenueDetails.CheckIn.ViewModel) {
        isCheckingIn = false
        checkin = viewModel.checkin
        updateButtons()
        hideLoader()
        VenueTracker.shared.isCheckingIn = false
        if let warning = viewModel.warning {
            UIAlertController.presentAsAlert(title: warning, actions:
                [("OK", .default, { [weak router] in router?.routeToVenueBill() })])
        } else {
            router?.routeToVenueBill()
        }
    }
    
    /// Displays an alert notifying user about tab opening failure according to given details.
    ///
    /// - Parameter viewModel: Tab opening failure details.
    func displayCheckinError(viewModel: VenueDetails.CheckIn.ViewModel) {
        hideLoader()
        let defaultAlert = {
            let title = "Could not check you in"
            let message = "Please try again."
            if UIApplication.shared.applicationState == .active {
                self.isCheckingIn = false
                VenueTracker.shared.isCheckingIn = false
                UIAlertController.presentAsAlert(title: title,
                                                 message: message,
                                                 actions: [("Cancel", .cancel, .none)])
            } else {
                let identifier = QorumPushIdentifier.openCheckinError.rawValue
                let content = UNMutableNotificationContent.create(with: title, body: message)
                VenueTrackerNotifier.showNotification(with: identifier, content: content)
            }
        }
        guard let error = viewModel.checkinError?["error_description"] as? GenericError else {
            defaultAlert()
            return
        }
        
        var alertTitle = "Tab Failed to Open:"
        let isAppActive = UIApplication.shared.applicationState == .active
        switch error.status {
        case 402:
            if !isAppActive {
                VenueTrackerNotifier.showChangePaymentRequestNotification(for: venue)
            } else {
                let message = "Please change your default payment method or add another payment method to open your tab."
                UIAlertController.presentAsAlert(title: alertTitle, message: message, actions:
                    [("Cancel", .cancel, { [weak self] in self?.cancelCheckinAction() }),
                     ("Change Payment", .default, { [weak self] in self?.changePaymentAction() })])
            }
        case 409:
            let message: String
            let actions: [UIAlertController.CustomAction]
            switch error.meta?.message {
            case "POS threw an unexpected error."?:
                message = "Please try again later or ask the bartender to check the POS system."
                actions = [("Cancel", .cancel, { [weak self] in self?.cancelCheckinAction() }),
                           ("Try again", .default, { [weak self] in self?.checkPreconditions() })]
            case "A request failed because of conflict."?,
                 "A request failed because of a conflict."?:
                message = "It looks like you might already have a tab open. Please try again later or ask the bartender directly."
                actions = [("Cancel", .cancel, { [weak self] in self?.cancelCheckinAction() }),
                           ("Try again", .default, { [weak self] in self?.checkPreconditions() })]
            default:
                alertTitle = "Oops!"
                message = error.message
                actions = [("Got It", .cancel, { [weak self] in self?.cancelCheckinAction() })]
            }
            
            if !isAppActive {
                let identifier = QorumPushIdentifier.openCheckinError.rawValue
                let content = UNMutableNotificationContent.create(with: alertTitle, body: message)
                VenueTrackerNotifier.showNotification(with: identifier, content: content)
            } else {
                UIAlertController.presentAsAlert(title: alertTitle, message: message, actions: actions)
            }
        default:
            defaultAlert()
        }
    }
    
    func displayAgeAlert() {
        isCheckingIn = false
        UIAlertController.presentAsAlert(message: "We're sorry, but you're not allowed to use Qorum until you are of legal drinking age.")
    }
    
    func displayOverlay(_ overlay: VenueDetails.Overlay) {
        switch overlay {
        case .facebook:
            let facebookOverlay = FacebookOverlayViewController.fromStoryboard
            self.overlay = facebookOverlay
            facebookOverlay.delegate = self
            add(childViewController: facebookOverlay)
            
            let reqOffset = (facebookButton.convert(facebookButton.frame, to: container).origin.y - 120)
            if reqOffset > 0 {
                shouldScrollToMap = false
                container.setContentOffset(CGPoint(x: 0, y: reqOffset), animated: false)
            }
        case .openBar:
            //TODO: - add implementation for showing Open Bar ovelay
            break
        }
    }
    
}

// MARK: - UIScrollViewDelegate
extension VenueDetailsViewController: UIScrollViewDelegate {
    
    /// Handles video playback according to gallery current item or content offset.
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        guard let videoView = gallery.playerView else { return }
        switch scrollView {
        case gallery:
            if gallery.currentInd > 0,
                videoView.isPlaying
            {
                videoView.stopPlaying()
            } else if
                !videoView.isPlaying,
                !videoView.userPaused,
                gallery.currentInd == 0,
                galleryGrid == nil
            {
                videoView.playMuted()
            }
        case container where gallery.currentInd == 0:
            if  videoView.isPlaying,
                container.contentOffset.y > galleryHeight.constant
            {
                videoView.stopPlaying()
            } else if
                !videoView.isPlaying,
                !videoView.userPaused,
                container.contentOffset.y <= galleryHeight.constant
            {
                videoView.playMuted()
            }
        default: break
        }
    }
    
    /// Tracks gallery current item.
    /// Handles gallery layout.
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if scrollView.isEqual(gallery) {
            gallery.currentInd = Int(floor((scrollView.contentOffset.x - gallery.viewWidth / 2) / gallery.viewWidth)) + 1
            if pageControlPressed {
                if pageControl.currentPage == gallery.currentInd {
                    pageControlPressed = false
                }
            } else {
                pageControl.currentPage = gallery.currentInd
            }
            
            gallery.updateLabel()
            gallery.navigationBackground.snp.updateConstraints { (update) in
                update.left.equalTo(gallery).offset(scrollView.contentOffset.x)
            }
        } else if scrollView.isEqual(container) {
            if container.contentOffset.y < 0 {
                if galleryTop.constant != container.contentOffset.y {
                    galleryTop.constant = container.contentOffset.y
                    galleryHeight.constant = .deviceWidth - container.contentOffset.y
                    pageControl.y = galleryHeight.constant - pageControl.height - 10 + container.contentOffset.y
                }
            } else {
                pageControl.y = galleryHeight.constant - pageControl.height - 10
            }
        } else {
            gallery.updateLabel()
            gallery.navigationBackground.snp.updateConstraints { (update) in
                update.left.equalTo(gallery).offset(scrollView.contentOffset.x)
            }
        }
    }
    
    func viewForZooming(in scrollView: UIScrollView) -> UIView? {
        return scrollView.subviews.first
    }
    
}

// MARK: - GMSMapViewDelegate
extension VenueDetailsViewController: GMSMapViewDelegate {
    
    func mapView(_ mapView: GMSMapView, didTap marker: GMSMarker) -> Bool {
        (marker as? VenueMarker)?.expand()
        return false
    }
    
    func mapView(_ mapView: GMSMapView, didLongPressAt coordinate: CLLocationCoordinate2D) {
        pinLongPressed(UILongPressGestureRecognizer(target: nil, action: nil))
    }
    
}

// MARK: - FacebookOverlayDelegate
extension VenueDetailsViewController: FacebookOverlayDelegate {
    
    /// Asks interactor to log user in.
    func connectButtonPressed() {
        interactor?.login()
    }
    
}

// MARK: - GenderMeasureViewDataSource
extension VenueDetailsViewController: GenderMeasureViewDataSource {
    
    func values(forView genderView: GenderMeasureView) -> (male: Int, female: Int) {
        guard let _venue = venue else { return (0,0) }
        return (_venue.checkedInMaleCount, _venue.checkedInFemaleCount)
    }
    
}
