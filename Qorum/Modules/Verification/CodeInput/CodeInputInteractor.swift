//
//  CodeInputInteractor.swift
//  Qorum
//
//  Created by Stanislav on 09.04.2018.
//  Copyright (c) 2018 Bizico. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CodeInputBusinessLogic {
    
    /// Verifies code entered by user
    ///
    /// - Parameter request: code to verify
    func verifyCode(request: CodeInput.Request)
    
    /// Disables submit code button for 60 sec
    func disableSubmitButton()
    
    /// Disables resend code button for 30 sec
    func disableResendButton()
    
    /// Requests code to verify phone number. User will receive it in sms
    func requestVerificationCode()
    
}

protocol CodeInputDataStore {
    var phone: NumberInput.Phone? { get set }
}

class CodeInputInteractor: CodeInputDataStore {
    
    var presenter: CodeInputPresentationLogic?
    private(set) lazy var worker = CodeInputWorker()
    private(set) lazy var profileWorker = ProfileWorker()
    private(set) lazy var numberInputWorker = NumberInputWorker()
    var submittingTimer: Timer?
    var resendTimer: Timer?
    var phone: NumberInput.Phone?
    
    deinit {
        resendTimer?.invalidate()
    }
    
}

// MARK: - CodeInputBusinessLogic
extension CodeInputInteractor: CodeInputBusinessLogic {
    
    func verifyCode(request: CodeInput.Request) {
        guard let phone = phone else {
            print("verifyCode failure: phone is missing!")
            return
        }
        presenter?.showLoader(message: "Verifying Code...")
        worker.verify(code: request.code, phone: phone) { [weak self, weak presenter, weak profileWorker] result in
            presenter?.hideLoader()
            let codeResponse: CodeInput.Response
            switch result {
            case let .value(success):
                if success {
                    let user = User.stored
                    user.isPhoneVerified = true
                    user.save()
                    profileWorker?.fetchAndSave(user: user)
                    codeResponse = .success(needsVerifyEmail: !user.isEmailVerified)
                    AnalyticsService.shared.track(event: MixpanelEvents.verifyPhoneVerificationSuccess.rawValue)
                } else {
                    codeResponse = .invalidCode
                }
            case let .error(error):
                if let genericError = error as? GenericError {
                    
                    switch (genericError.status, genericError.detail.description) {
                        
                        case (401, "Verification code is incorrect"):
                            codeResponse = .invalidCode
                            self?.disableSubmitButton()
                        case (404, let message) where message.hasPrefix("No pending verifications"):
                            codeResponse = .noPendingVerifications
                        case (429, _):
                            codeResponse = .reachedRequestsLimit
                        default:
                            codeResponse = .error(error)
                    }
                } else {
                    codeResponse = .error(error)
                }
            }
            presenter?.present(response: codeResponse)
        }
    }
    
    func disableSubmitButton() {
        submittingTimer?.invalidate()
        let countdownStarted = UserDefaults.standard.object(forKey: UserDefaultsKeys.codeInputLastFailedSubmit.rawValue) as? Date ?? Date()
        UserDefaults.standard.set(countdownStarted, forKey: UserDefaultsKeys.codeInputLastFailedSubmit.rawValue)
        let timeout = CodeInput.submittingTimeout
        let timeToResend: () -> Int = {
            return Int(ceil(countdownStarted.timeIntervalSinceNow + timeout))
        }
        presenter?.present(response: .secondsToSubmit(timeToResend()))
        submittingTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak presenter] timer in
            let time = timeToResend()
            guard time <= 0 else {
                presenter?.present(response: .secondsToSubmit(time))
                return
            }
            timer.invalidate()
            UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.codeInputLastFailedSubmit.rawValue)
            presenter?.present(response: .mayReSubmit)
        }
    }
    
    func disableResendButton() {
        resendTimer?.invalidate()
        let countdownStarted = Date()
        let timeout = CodeInput.resendTimeout
        let timeToResend: () -> Int = {
            return Int(ceil(countdownStarted.timeIntervalSinceNow + timeout))
        }
        presenter?.present(response: .secondsToResend(timeToResend()))
        resendTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak presenter] timer in
            let time = timeToResend()
            guard time <= 0 else {
                presenter?.present(response: .secondsToResend(time))
                return
            }
            timer.invalidate()
            presenter?.present(response: .mayResend)
        }
    }
    
    func requestVerificationCode() {
        guard let phone = phone else {
            print("requestVerificationCode failure: phone is missing!")
            return
        }
        numberInputWorker.verify(phone: phone) { [weak presenter] response in
            if case let .error(error) = response {
                presenter?.present(response: .error(error))
            }
        }
    }
    
}

