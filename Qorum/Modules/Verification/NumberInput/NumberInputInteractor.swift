//
//  NumberInputInteractor.swift
//  Qorum
//
//  Created by Stanislav on 05.04.2018.
//  Copyright (c) 2018 Bizico. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol NumberInputBusinessLogic {
    
    /// Fetches user's phone
    ///
    func fetchPhone()
    
    /// Validates phone number from string
    ///
    /// - Parameter request: NumberInput.Request.number with phone string
    func validatePhone(request: NumberInput.Request)
    
    
    /// Checks does user's email verified
    ///
    /// - Returns: true for verified email
    func needsVerifyEmail() -> Bool
}

protocol NumberInputDataStore {
    var phone: NumberInput.Phone? { get set }
}

class NumberInputInteractor: NumberInputDataStore {
    var presenter: NumberInputPresentationLogic?
    private(set) lazy var worker = NumberInputWorker()
    private(set) lazy var profileWorker = ProfileWorker()
    var phone: NumberInput.Phone?
}

// MARK: - NumberInputBusinessLogic
extension NumberInputInteractor: NumberInputBusinessLogic {
    
    func fetchPhone() {
        if let phone = User.stored.phoneFormatted {
            presenter?.present(response: .phone(phone))
        }
    }
    
    func validatePhone(request: NumberInput.Request) {
        let validationResult = worker.validatePhone(number: request.number, for: User.stored)
        switch validationResult {
        case .value(let phone):
            self.phone = phone
            presenter?.showLoader(message: "Submitting Phone Number...")
            worker.verify(phone: phone) { [weak presenter, weak profileWorker] response in
                presenter?.hideLoader()
                if case .success = response {
                    let user = User.stored
                    user.mobileNumber = "\(phone.countryCode)\(phone.phoneNumber)"
                    user.isPhoneVerified = false
                    user.save()
                    profileWorker?.fetchAndSave(user: user)
                }
                presenter?.present(response: response)
            }
        case .error(let error):
            self.phone = nil
            if (error as? String) == "PLEASE ENTER A DIFFERENT PHONE NUMBER" {
                presenter?.present(response: .error(error))
                return
            }
            print("validatePhone error:", error)
            presenter?.present(response: .invalidNumber)
        }
    }
    
    func needsVerifyEmail() -> Bool {
        return !User.stored.isEmailVerified
    }
    
}

