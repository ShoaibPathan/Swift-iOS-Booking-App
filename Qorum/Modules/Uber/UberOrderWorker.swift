//
//  UberOrderWorker.swift
//  Qorum
//
//  Created by Vadym Riznychok on 12/4/17.
//  Copyright (c) 2017 Bizico. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftyJSON
import Moya
import Mixpanel

class UberOrderWorker {
    
    var classes: [UberClass] = []
    var estimatesStartLocation: CLLocationCoordinate2D = CLLocationCoordinate2D()
    var estimatesFinishLocation: CLLocationCoordinate2D = CLLocationCoordinate2D()
    
    //MARK: - Loading all products(UberTypes) and estimates
    func getProducts(from startLocation: CLLocationCoordinate2D,
                     to finishLocation: CLLocationCoordinate2D,
                     accessToken: String,
                     completion: @escaping APIHandler<[UberClass]>) {
        guard let userCoordinates = LocationService.shared.location?.coordinate else {
            completion(.error("Getting Uber products failure: missing user coordinates"))
            return
        }
        guard User.stored.settings.uber_token != nil else {
            completion(.error("Getting Uber products failure: missing Uber token"))
            return
        }
        
        estimatesStartLocation = startLocation
        estimatesFinishLocation = finishLocation
        
        let request = UberRequest(target: .products(location: userCoordinates))
        request.perform { [weak self] response in
            guard let worker = self else {
                completion(.error("Getting Uber products failure: missing UberOrderWorker reference"))
                return
            }
            switch response.result {
            case let .value(json):
                //Parse products(UberTypes) into classes
                let productsJson = json["products"].array?.filter({ $0["product_id"].string != nil }) ?? []
                var products = productsJson.map({ UberProduct.safelyFrom(json: $0) })
    
                if let product = products.first(where: { (product) -> Bool in
                        product.display_name.lowercased() == "pool" || product.display_name.lowercased() == "uberpool"
                    })
                {
                    let poolFix = product.copy()
                    poolFix.capacity = 1
                    poolFix.display_name.append("1")
                    products.append(poolFix)
                }
                
                let classes = UberClass.classesFrom(products: products)
                
                //Loading estimates for products(parsed into classes as UberTypes)
                worker.classes = classes
                worker.loadEstimates() { (result) in
                    switch result {
                    case let .value(loadedClasses):
                        //Filter updated classes
                        let resultClasses: [UberClass] = loadedClasses.reduce(into: [], { (result, uberClass) in
                            uberClass.clearFromEmptyEstimates()
                            if !uberClass.isEmpty() {
                                result.append(uberClass)
                            }
                        }) as? [UberClass] ?? []
                        
                        completion(.value(resultClasses))
                    case let .error(error):
                        print("UberOrderWorker getProducts error - failed to load estimates:\n\(error)")
                        completion(.error(error))
                    }
                }
            case let .error(error):
                print("UberOrderWorker getProducts error:", error)
                completion(.error(error))
            }
        }
    }
    
    // Load estimates for each product(UberType) contained in classes
    func loadEstimates(completion: @escaping APIHandler<[UberClass]>) {
        guard let classToLoad = classes.first(where: { $0.hasNotLoadedEstimate() }) else {
            completion(.error("Estimates load failure: missing class to load"))
            return
        }
        guard let typeToLoad = classToLoad.types.first(where: { $0.estimate == nil }) else {
            completion(.error("Estimates load failure: missing type to load in \(classToLoad.name) class"))
            return
        }
        
        //Load estimate for exact product(UberType)
        
        //pool1 is @uber_pool_fix, there are 2 different estimates, but we need to show only one
        var seatCount: Int? = nil
        if typeToLoad.name.lowercased() == "pool1" || typeToLoad.name.lowercased() == "uberpool1" {
            seatCount = 1
        }
        let request = UberRequest(target: .estimate(productId: typeToLoad.productData!.product_id,
                                                    seatsCount: seatCount,
                                                    startLocation: estimatesStartLocation,
                                                    finishLocation: estimatesFinishLocation))
        self.uberTypeEstimate(request: request) { (result) in
            switch result {
            case let .value(result):
                typeToLoad.estimate = result
            case let .error(error):
                typeToLoad.estimate = UberTypeEstimate(data: [:])
                print("UberOrderWorker loadEstimates - uberTypeEstimate error:", error)
            }
            
            if self.classes.contains(where: { $0.hasNotLoadedEstimate() }) {
                self.loadEstimates(completion: completion)
            } else {
                completion(.value(self.classes))
            }
        }
    }
    
    //Load estimate for exact product(UberType)
    func uberTypeEstimate(uberData: UberRequestData,
                          completion:  @escaping APIHandler<UberTypeEstimate>) {
        if let productId = uberData.type?.productData?.product_id {
            let request = UberRequest(target: .estimate(productId: productId,
                                                        seatsCount: uberData.seatsCount,
                                                        startLocation: estimatesStartLocation,
                                                        finishLocation: estimatesFinishLocation))
            self.uberTypeEstimate(request: request, completion: completion)
        } else {
            completion(.error(NSError()))
        }
    }
    
    func uberTypeEstimate(request: UberRequest,
                          completion: @escaping APIHandler<UberTypeEstimate>) {
        request.perform { response in
            switch response.result {
            case let .value(json):
                do {
                    let dict = try json.expectingDictionary()
                    completion(.value(UberTypeEstimate(data: dict)))
                } catch {
                    completion(.error(error))
                }
            case let .error(error):
                print("UberOrderWorker estimate error:", error)
                completion(.error(error))
            }
        }
    }
    
    //MARK: - Load Route
    func loadRoute(sensor: String,
                   origin: String,
                   destination: String,
                   language: String,
                   completion: @escaping APIHandler<GoogleDirection>) {
        let request = DirectionsRequest(target: .directions(sensor: sensor,
                                                            origin: origin,
                                                            destination: destination,
                                                            language: language,
                                                            key: SocialServiceKeys.qorumGMSServicesAPIKey))
        request.performDecoding(completion: completion)
    }
    
    //MARK: - Registration
    func registerUberToken(authorizationCode: String,
                           completion: @escaping APIHandler<String>) {
        let user = User.stored
        if user.isGuest {
            completion(.error("registerUberToken denied: guest mode detected"))
            return
        }
        let request = RideRequest(target: .registerUberToken(authCode: authorizationCode,
                                                             userId: user.userId))
        request.perform { response in
            switch response.result {
            case let .value(json):
                do {
                    let accessToken = try json["resp"]["access_token"].expectingString()
                    completion(.value(accessToken))
                } catch {
                    completion(.error(error))
                }
            case let .error(error):
                completion(.error(error))
            }
        }
    }
    
    //MARK: - Ride
    func orderUber(uberData: UberRequestData,
                   completion: @escaping (_ success: Bool, _ uberRequestId: String?, _ error: Any?) -> ()) {
        let request = UberRequest(target: .orderUber(uberData: uberData))
        request.perform { response in
            switch response.result {
            case let .value(json):
                guard let requestId = json["request_id"].string else {
                    print("UberOrderWorker orderUber error: missing requestId; json response:\n", json)
                    guard
                        let error = json["errors"].array?.first,
                        let title = error["title"].string,
                        let code = error["code"].string else
                    {
                        
//                        AnalyticsService.shared.track(event: MixpanelEvents.orderUberError.rawValue,
//                                                      properties: ["error": json.string ?? ""])
                        completion(false, nil, nil)
                        return
                    }
                    
                    if code == "surge" {
                        let href = json["meta"]["surge_confirmation"]["href"].string
                        completion(false, href, title)
                        return
                    }
                    
                    if kUberPaymentErrorCodesList.keys.contains(code) {
                        completion(false, nil, error.dictionaryObject as AnyObject)
                        return
                    }
                    
                    completion(false, nil, title)
                    return
                }
                completion(true, requestId, nil)
            case let .error(error):
                print("UberOrderWorker orderUber error:", error)
                guard let errorTitle = (error as? GenericError)?.title else {
//                    AnalyticsService.shared.track(event: MixpanelEvents.orderUberError.rawValue,
//                                                  properties: ["error": error.localizedDescription])
                    completion(false, nil, nil)
                    return
                }
                
                completion(false, nil, errorTitle)
            }
        }
    }
    
    func registerRide(requestId: String,
                      uberData: UberRequestData,
                      completion: @escaping APIHandler<String>) {
        let user = User.stored
        guard !user.isGuest else {
            completion(.error("UberOrderWorker registerRide error: missing stored user"))
            return
        }
        let request = RideRequest(target: .registerRide(userId: user.userId, requestId: requestId, uberData: uberData))
        request.perform { response in
            switch response.result {
            case let .value(json):
                do {
                    let rideId = try json["data"]["id"].expectingString()
                    completion(.value(rideId))
                } catch {
                    completion(.error(error))
                }
            case let .error(error):
                completion(.error(error))
            }
        }
    }
    
    //MARK: - Promo codes
    func checkRidePromo(checkinId: Int,
                        userId: Int,
                        completion: @escaping (_ success: Bool) -> ()) {
        let request = RideRequest(target: .checkRidePromo(userId: userId, checkinId: checkinId))
        request.perform { response in
            switch response.result {
            case let .value(json):
                print("UberOrderWorker checkRidePromo response:\n", json)
                completion(true)
            case let .error(error):
                print("UberOrderWorker checkRidePromo error:", error)
                completion(false)
            }
        }
    }
    
    func applyRidePromo(rideId: String,
                        checkinId: Int,
                        userId: Int,
                        completion: @escaping (UberOrder.ApplyPromo.Response) -> ()) {
        let request = RideRequest(target: .applyRidePromo(userId: userId, rideId: rideId, checkinId: checkinId))
        request.perform { response in
            switch response.result {
            case let .value(json):
                print("UberOrderWorker applyRidePromo response:\n", json)
                completion(.success)
            case let .error(error):
                print("UberOrderWorker applyRidePromo error:", error)
                guard let genericError = error as? GenericError else {
                    completion(.error(error))
                    return
                }
                let code = genericError.detail["errors"][0]["code"].string ??
                    genericError.detail["code"].string ??
                    genericError.code
                switch code {
                case "promotion_code_already_applied":
                    completion(.alreadyApplied)
                case "promotion_code_invalid":
                    completion(.invalidPromo)
                default:
                    completion(.error(error))
                }
            }
        }
    }
    
    //MARK: - Cancel
    func cancelUber(requestId: String, completion: @escaping (_ success: Bool) -> ()) {
        let request = UberRequest(target: .cancelUber(requestId: requestId))
        request.perform { response in
            switch response.result {
            case let .value(json):
                print("UberOrderWorker cancelUber response:\n", json)
                completion(true)
            case let .error(error):
                print("UberOrderWorker cancelUber error:", error)
                completion(false)
            }
        }
    }
    
    //MARK: - Payments
    func loadUberPayments(completion: @escaping (Bool, [UberPaymentMethod]?, String?) -> ()) {
        let request = UberRequest(target: .payments())
        request.perform { response in
            switch response.result {
            case let .value(json):
                if let methods = try? UberPaymentMethod.arrayFrom(json: json["payment_methods"]) {
                    completion(true, methods, json["last_used"].string)
                    return
                }
                print("UberOrderWorker loadUberPayments response:\n", json)
                completion(false, nil, nil)
            case let .error(error):
                print("UberOrderWorker loadUberPayments error:", error)
                completion(false, nil, nil)
            }
        }
    }
    
}

